package com.onekr.designmodel.observer;

/**
 * Observer模式
 * 
简单地说，观察者模式定义了一个一对多的依赖关系，让一个或多个观察者对象监察一个主题对象。这样一个主题对象在状态上的变化能够通知所有的依赖于此对象的

那些观察者对象，使这些观察者对象能够自动更新。

抽象主题（Subject）角色：主题角色把所有的观察者对象的引用保存在一个列表里；每个主题都可以有任何数量的观察者。主题提供一个接口可以加上或撤销观察者对象； 
抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到通知时更新自己； 
具体主题（ConcreteSubject）角色：保存对具体观察者对象有用的内部状态；在这种内部状态改变时给其观察者发出一个通知；
具体观察者（ConcreteObserver）角色：保存一个指向具体主题对象的引用；和一个与主题的状态相符的状态。具体观察者角色实现抽象观察者角色所要求的更新自己的接口，以便使本身的状态与主题的状态自恰。 



在Java语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成Java语言对观察者模式的支持。


观察者模式的总结

　　观察者模式的效果有以下的优点：

　　第一、观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。

　　由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。

　　第二、观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知，

　　观察者模式有下面的缺点：

　　第一、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。

　　第二、如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。

　　第三、如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。

　　第四、虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。

　　观察者模式与其它模式的关系

　　观察者模式使用了备忘录模式(Memento Pattern)暂时将观察者对象存储在被观察者对象里面。


 * 
 *
 */
public class Test {
	public static void main(String[] args) {
		NumObservable number = new NumObservable();
		number.addObserver(new NumObserver());
		number.setData(1);
		number.setData(2);
		number.setData(3);
	}
}
